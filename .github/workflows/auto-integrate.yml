name: Auto-integrate to DroneLeaf/DroneLeaf_WebClient

on:
  pull_request:
    types: [closed]
    branches:
      - main

concurrency:
  group: auto-integrate-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  sync-and-pr:
    name: Sync mapped files to target repo and open PR
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true

    # GITHUB_TOKEN is used to read this repo; a PAT is required for the private target repo
    permissions:
      contents: read
      pull-requests: read

    env:
      OWNER: ${{ github.repository_owner }} # override if target repo lives under a different owner
      TARGET_REPO: DroneLeaf_WebClient
      TARGET_BASE: feat/migration-new
      SOURCE_BRANCH: ${{ github.ref_name }}
      TARGET_BRANCH: auto-integrate-br

    steps:
      - name: Checkout source repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure copy settings file exists
        run: |
          test -f .github/copy_settings.yaml || {
            echo "❌ .github/copy_settings.yaml not found" >&2; exit 1;
          }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install Python deps
        run: python -m pip install --upgrade pip pyyaml

      - name: Clone target repo and create/update branch from base
        env:
          GH_PAT: ${{ secrets.TOKEN }}
        run: |
          set -euo pipefail
          : "${OWNER:?}"
          : "${TARGET_REPO:?}"
          : "${TARGET_BASE:?}"
          : "${TARGET_BRANCH:?}"

          # Clone the target repo at the base branch
          git clone --no-tags --single-branch \
            --branch "${TARGET_BASE}" \
            "https://x-access-token:${GH_PAT}@github.com/${OWNER}/${TARGET_REPO}.git" target_repo

          cd target_repo
          # Create/update the working branch based on the base branch
          git checkout -B "${TARGET_BRANCH}" "origin/${TARGET_BASE}"

      - name: Apply copy map from .github/copy_settings.yaml
        run: |
          set -euo pipefail
          python << 'PY'
          import os, sys, shutil, yaml, pathlib, glob

          SRC_ROOT = pathlib.Path(os.getenv('GITHUB_WORKSPACE', '.')).resolve()
          TGT_ROOT = pathlib.Path('target_repo').resolve()
          CFG_PATH = SRC_ROOT / '.github' / 'copy_settings.yaml'

          print(f"Reading copy settings from {CFG_PATH}")
          with open(CFG_PATH, 'r', encoding='utf-8') as f:
              cfg = yaml.safe_load(f) or {}

          mappings = cfg.get('mappings') or cfg.get('map') or []
          if not isinstance(mappings, list) or not mappings:
              print('No mappings found in copy_settings.yaml (expected key: mappings:).', file=sys.stderr)
              sys.exit(1)

          # Utility: ensure dest parent exists
          def ensure_parent(p: pathlib.Path):
              p.parent.mkdir(parents=True, exist_ok=True)

          # Utility: check if path contains wildcards
          def has_wildcards(path_str):
              return '*' in path_str or '?' in path_str or '[' in path_str

          # Utility: safely resolve glob patterns
          def safe_glob(pattern, root):
              """Safely resolve glob patterns relative to root directory"""
              try:
                  # Use glob with root_dir parameter for safer globbing
                  matches = list(pathlib.Path(root).glob(pattern))
                  # Filter to ensure all matches are within the root
                  safe_matches = []
                  for match in matches:
                      try:
                          resolved = match.resolve()
                          if str(resolved).startswith(str(root)):
                              safe_matches.append(resolved)
                      except (OSError, ValueError):
                          continue
                  return safe_matches
              except (OSError, ValueError):
                  return []

          # Copy logic
          for i, entry in enumerate(mappings, 1):
              src_rel = entry.get('from') or entry.get('src')
              dst_rel = entry.get('to') or entry.get('dest')
              mode = (entry.get('type') or entry.get('mode') or '').lower()
              recursive = entry.get('recursive', True)

              if not src_rel or not dst_rel:
                  print(f"Mapping #{i} missing 'from'/'to'.", file=sys.stderr)
                  sys.exit(1)

              # Handle wildcard patterns in source
              if has_wildcards(src_rel):
                  print(f"[{i}] glob: {src_rel} -> {dst_rel} (recursive={recursive})")
                  
                  # Find all matching files/dirs
                  matches = safe_glob(src_rel, SRC_ROOT)
                  
                  if not matches:
                      print(f"Warning: No matches found for glob pattern: {src_rel}")
                      continue
                  
                  for match in matches:
                      # Calculate relative path from source root
                      try:
                          rel_path = match.relative_to(SRC_ROOT)
                      except ValueError:
                          print(f"Skipping match outside source root: {match}")
                          continue
                      
                      # Determine destination path
                      if dst_rel.endswith('/') or pathlib.Path(dst_rel).suffix == '':
                          # Destination is a directory, preserve source filename/dirname
                          dst = (TGT_ROOT / dst_rel / match.name).resolve()
                      else:
                          # Direct mapping - only works if single match
                          if len(matches) > 1:
                              print(f"Error: Multiple glob matches but destination is not a directory: {dst_rel}", file=sys.stderr)
                              sys.exit(1)
                          dst = (TGT_ROOT / dst_rel).resolve()
                      
                      # Security check
                      if not str(dst).startswith(str(TGT_ROOT)):
                          print(f"Destination path escapes target: {dst}", file=sys.stderr)
                          sys.exit(1)
                      
                      # Perform copy based on source type
                      if match.is_file():
                          ensure_parent(dst)
                          if dst.exists() and dst.is_file():
                              dst.unlink()
                          shutil.copy2(match, dst)
                          print(f"  Copied file: {rel_path} -> {dst.relative_to(TGT_ROOT)}")
                      elif match.is_dir():
                          if dst.exists():
                              if dst.is_dir():
                                  shutil.rmtree(dst)
                              else:
                                  dst.unlink()
                          if recursive:
                              shutil.copytree(match, dst)
                          else:
                              dst.mkdir(parents=True, exist_ok=True)
                              for item in match.iterdir():
                                  if item.is_file():
                                      shutil.copy2(item, dst / item.name)
                          print(f"  Copied dir: {rel_path} -> {dst.relative_to(TGT_ROOT)}")
              else:
                  # Original non-wildcard logic (unchanged for compatibility)
                  src = (SRC_ROOT / src_rel).resolve()
                  dst = (TGT_ROOT / dst_rel).resolve()

                  if not str(src).startswith(str(SRC_ROOT)):
                      print(f"Source path escapes repo: {src}", file=sys.stderr)
                      sys.exit(1)
                  if not str(dst).startswith(str(TGT_ROOT)):
                      print(f"Destination path escapes target: {dst}", file=sys.stderr)
                      sys.exit(1)

                  if not src.exists():
                      print(f"Source does not exist: {src}", file=sys.stderr)
                      sys.exit(1)

                  # Infer mode if omitted
                  if not mode:
                      mode = 'dir' if src.is_dir() else 'file'

                  print(f"[{i}] {mode}: {src_rel} -> {dst_rel} (recursive={recursive})")

                  if mode == 'file':
                      ensure_parent(dst)
                      # Remove existing file if present to avoid stale content
                      if dst.exists() and dst.is_file():
                          dst.unlink()
                      shutil.copy2(src, dst)
                  elif mode == 'dir':
                      if dst.exists():
                          # Remove existing destination to get a clean mirror
                          if dst.is_dir():
                              shutil.rmtree(dst)
                          else:
                              dst.unlink()
                      if recursive:
                          shutil.copytree(src, dst)
                      else:
                          # non-recursive: copy only immediate children files
                          dst.mkdir(parents=True, exist_ok=True)
                          for item in src.iterdir():
                              if item.is_file():
                                  shutil.copy2(item, dst / item.name)
                  else:
                      print(f"Unsupported type in mapping #{i}: {mode}", file=sys.stderr)
                      sys.exit(1)

          print('Copy operations completed.')
          PY

      - name: Commit and push changes to target branch
        env:
          GH_PAT: ${{ secrets.TOKEN }}
        run: |
          set -euo pipefail
          cd target_repo
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "Auto integrate from ${{ github.repository }}@${{ env.SOURCE_BRANCH }} (commit: ${{ github.sha }})"
            git push -u origin "${TARGET_BRANCH}" --force-with-lease
            echo "NO_CHANGES=false" >> "$GITHUB_ENV"
          else
            echo "No changes detected; skipping PR creation."
            echo "NO_CHANGES=true" >> "$GITHUB_ENV"
          fi

      - name: Create or update PR in target repo
        if: env.NO_CHANGES != 'true'
        env:
          GH_TOKEN: ${{ secrets.TOKEN }}
        run: |
          set -euo pipefail
          : "${OWNER:?}${TARGET_REPO:?}${TARGET_BASE:?}${TARGET_BRANCH:?}"
          cd target_repo

          # If a PR already exists for this head->base, add a comment; else create it
          PR_NUMBER=$(gh pr list \
            --repo "${OWNER}/${TARGET_REPO}" \
            --head "${TARGET_BRANCH}" \
            --base "${TARGET_BASE}" \
            --json number --jq '.[0].number') || true

          PR_TITLE="Auto integrate: droneleaf-user-journey-ha/${SOURCE_BRANCH} → ${TARGET_BASE}"
          PR_BODY=$(cat <<'EOB'
          This PR was auto-created by the **Auto-integrate** workflow.

          - **Source repo/branch:** ${{ github.repository }}@${{ env.SOURCE_BRANCH }}
          - **Source commit:** ${{ github.sha }}
          - **Target base:** ${{ env.TARGET_BASE }}
          - **Target head:** ${{ env.TARGET_BRANCH }}

          Changes were copied according to `.github/copy_settings.yaml` in the source repository.
          EOB
          )

          if [ -z "$PR_NUMBER" ]; then
            gh pr create \
              --repo "${OWNER}/${TARGET_REPO}" \
              --base "${TARGET_BASE}" \
              --head "${TARGET_BRANCH}" \
              --title "$PR_TITLE" \
              --body  "$PR_BODY"
          else
            gh pr comment "${PR_NUMBER}" \
              --repo "${OWNER}/${TARGET_REPO}" \
              --body "Updated from source commit ${{ github.sha }}"
          fi
