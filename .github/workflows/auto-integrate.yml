name: Auto-integrate to DroneLeaf/DroneLeaf_WebClient

on:
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      source_branch:
        description: 'Source branch to sync from'
        required: true
        default: 'main'
        type: string
      reason:
        description: 'Reason for manual sync'
        required: false
        type: string

concurrency:
  group: auto-integrate-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  check-permissions:
    name: Check user permissions for manual trigger
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
    steps:
      - name: Check if user is authorized
        id: check
        run: |
          # List of authorized users (replace with actual GitHub usernames)
          AUTHORIZED_USERS="omaralblooshi100067891 ahmed-hashim-pro"
          
          if echo "$AUTHORIZED_USERS" | grep -q "${{ github.actor }}"; then
            echo "User ${{ github.actor }} is authorized"
            echo "authorized=true" >> $GITHUB_OUTPUT
          else
            echo "User ${{ github.actor }} is not authorized to run this workflow manually"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  sync-and-pr:
    name: Sync mapped files to target repo and open PR
    runs-on: ubuntu-latest
    needs: [check-permissions]
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch' && needs.check-permissions.outputs.authorized == 'true')

    # GITHUB_TOKEN is used to read this repo; a PAT is required for the private target repo
    permissions:
      contents: read
      pull-requests: read

    env:
      OWNER: ${{ github.repository_owner }} # override if target repo lives under a different owner
      TARGET_REPO: DroneLeaf_WebClient
      TARGET_BASE: auto-migration-br
      SOURCE_BRANCH: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.source_branch || github.ref_name }}
      TARGET_BRANCH: auto-migration-br

    steps:
      - name: Checkout source repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure copy settings file exists
        run: |
          test -f .github/copy_settings.yaml || {
            echo "❌ .github/copy_settings.yaml not found" >&2; exit 1;
          }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install Python deps
        run: python -m pip install --upgrade pip pyyaml

      - name: Clone target repo and create/update branch from base
        env:
          GH_PAT: ${{ secrets.TOKEN }}
        run: |
          set -euo pipefail
          : "${OWNER:?}"
          : "${TARGET_REPO:?}"
          : "${TARGET_BASE:?}"
          : "${TARGET_BRANCH:?}"

          # Clone the target repo at the base branch
          git clone --no-tags --single-branch \
            --branch "${TARGET_BASE}" \
            "https://x-access-token:${GH_PAT}@github.com/${OWNER}/${TARGET_REPO}.git" target_repo

          cd target_repo
          # Create/update the working branch based on the base branch
          git checkout -B "${TARGET_BRANCH}" "origin/${TARGET_BASE}"

      - name: Apply copy map from .github/copy_settings.yaml
        run: |
          set -euo pipefail
          python << 'PY'
          import os, sys, shutil, yaml, pathlib, glob

          SRC_ROOT = pathlib.Path(os.getenv('GITHUB_WORKSPACE', '.')).resolve()
          TGT_ROOT = pathlib.Path('target_repo').resolve()
          CFG_PATH = SRC_ROOT / '.github' / 'copy_settings.yaml'

          print(f"Reading copy settings from {CFG_PATH}")
          with open(CFG_PATH, 'r', encoding='utf-8') as f:
              cfg = yaml.safe_load(f) or {}

          mappings = cfg.get('mappings') or cfg.get('map') or []
          if not isinstance(mappings, list) or not mappings:
              print('No mappings found in copy_settings.yaml (expected key: mappings:).', file=sys.stderr)
              sys.exit(1)

          # Utility: ensure dest parent exists
          def ensure_parent(p: pathlib.Path):
              p.parent.mkdir(parents=True, exist_ok=True)

          # Utility: check if path contains wildcards
          def has_wildcards(path_str):
              return '*' in path_str or '?' in path_str or '[' in path_str

          # Utility: safely resolve glob patterns
          def safe_glob(pattern, root):
              """Safely resolve glob patterns relative to root directory"""
              try:
                  # Use glob with root_dir parameter for safer globbing
                  matches = list(pathlib.Path(root).glob(pattern))
                  # Filter to ensure all matches are within the root
                  safe_matches = []
                  for match in matches:
                      try:
                          resolved = match.resolve()
                          if str(resolved).startswith(str(root)):
                              safe_matches.append(resolved)
                      except (OSError, ValueError):
                          continue
                  return safe_matches
              except (OSError, ValueError):
                  return []

          # Utility: check if path should be ignored based on ignore patterns
          def should_ignore(path, ignore_patterns, src_root):
              """Check if a path should be ignored based on ignore patterns"""
              if not ignore_patterns:
                  return False
              
              try:
                  rel_path = path.relative_to(src_root)
                  rel_path_str = str(rel_path)
                  
                  for pattern in ignore_patterns:
                      # Support both glob patterns and exact matches
                      if has_wildcards(pattern):
                          # Use glob matching
                          import fnmatch
                          if fnmatch.fnmatch(rel_path_str, pattern):
                              return True
                      else:
                          # Exact path matching
                          if rel_path_str == pattern or rel_path_str.startswith(pattern + '/'):
                              return True
              except ValueError:
                  pass
              return False

          # Copy logic
          for i, entry in enumerate(mappings, 1):
              src_rel = entry.get('from') or entry.get('src')
              dst_rel = entry.get('to') or entry.get('dest')
              mode = (entry.get('type') or entry.get('mode') or '').lower()
              recursive = entry.get('recursive', True)
              ignore_patterns = entry.get('ignore') or entry.get('exclude') or []
              
              # Ensure ignore_patterns is a list
              if isinstance(ignore_patterns, str):
                  ignore_patterns = [ignore_patterns]

              if not src_rel or not dst_rel:
                  print(f"Mapping #{i} missing 'from'/'to'.", file=sys.stderr)
                  sys.exit(1)

              # Handle wildcard patterns in source
              if has_wildcards(src_rel):
                  print(f"[{i}] glob: {src_rel} -> {dst_rel} (recursive={recursive})")
                  
                  # Find all matching files/dirs
                  matches = safe_glob(src_rel, SRC_ROOT)
                  
                  if not matches:
                      print(f"Warning: No matches found for glob pattern: {src_rel}")
                      continue
                  
                  for match in matches:
                      # Calculate relative path from source root
                      try:
                          rel_path = match.relative_to(SRC_ROOT)
                      except ValueError:
                          print(f"Skipping match outside source root: {match}")
                          continue
                      
                      # Check if this match should be ignored
                      if should_ignore(match, ignore_patterns, SRC_ROOT):
                          print(f"  Ignoring: {rel_path}")
                          continue
                      
                      # Determine destination path
                      if dst_rel.endswith('/') or pathlib.Path(dst_rel).suffix == '':
                          # Destination is a directory, preserve source filename/dirname
                          dst = (TGT_ROOT / dst_rel / match.name).resolve()
                      else:
                          # Direct mapping - only works if single match
                          if len(matches) > 1:
                              print(f"Error: Multiple glob matches but destination is not a directory: {dst_rel}", file=sys.stderr)
                              sys.exit(1)
                          dst = (TGT_ROOT / dst_rel).resolve()
                      
                      # Security check
                      if not str(dst).startswith(str(TGT_ROOT)):
                          print(f"Destination path escapes target: {dst}", file=sys.stderr)
                          sys.exit(1)
                      
                      # Perform copy based on source type
                      if match.is_file():
                          ensure_parent(dst)
                          if dst.exists() and dst.is_file():
                              dst.unlink()
                          shutil.copy2(match, dst)
                          print(f"  Copied file: {rel_path} -> {dst.relative_to(TGT_ROOT)}")
                      elif match.is_dir():
                          # For wildcard matches, use additive/merge behavior for directories
                          def copy_dir_additive(src_dir, dst_dir, recursive_flag):
                              """Copy directory contents additively (merge, don't replace)"""
                              dst_dir.mkdir(parents=True, exist_ok=True)
                              
                              for item in src_dir.iterdir():
                                  src_item = item
                                  dst_item = dst_dir / item.name
                                  
                                  # Check if this item should be ignored
                                  if should_ignore(src_item, ignore_patterns, SRC_ROOT):
                                      continue
                                  
                                  if src_item.is_file():
                                      # Always overwrite files
                                      if dst_item.exists() and dst_item.is_file():
                                          dst_item.unlink()
                                      elif dst_item.exists() and dst_item.is_dir():
                                          # Remove conflicting directory
                                          shutil.rmtree(dst_item)
                                      shutil.copy2(src_item, dst_item)
                                  elif src_item.is_dir() and recursive_flag:
                                      # Recursively merge subdirectories
                                      copy_dir_additive(src_item, dst_item, recursive_flag)
                                  elif src_item.is_dir() and not recursive_flag:
                                      # Non-recursive: only create empty directory
                                      dst_item.mkdir(exist_ok=True)
                          
                          # Remove conflicting file if destination exists as file
                          if dst.exists() and dst.is_file():
                              dst.unlink()
                          
                          copy_dir_additive(match, dst, recursive)
                          print(f"  Merged dir: {rel_path} -> {dst.relative_to(TGT_ROOT)}")
              else:
                  # Original non-wildcard logic (unchanged for compatibility)
                  src = (SRC_ROOT / src_rel).resolve()
                  dst = (TGT_ROOT / dst_rel).resolve()

                  if not str(src).startswith(str(SRC_ROOT)):
                      print(f"Source path escapes repo: {src}", file=sys.stderr)
                      sys.exit(1)
                  if not str(dst).startswith(str(TGT_ROOT)):
                      print(f"Destination path escapes target: {dst}", file=sys.stderr)
                      sys.exit(1)

                  if not src.exists():
                      print(f"Source does not exist: {src}", file=sys.stderr)
                      sys.exit(1)

                  # Check if this source should be ignored
                  if should_ignore(src, ignore_patterns, SRC_ROOT):
                      print(f"[{i}] Ignoring: {src_rel}")
                      continue

                  # Infer mode if omitted
                  if not mode:
                      mode = 'dir' if src.is_dir() else 'file'

                  print(f"[{i}] {mode}: {src_rel} -> {dst_rel} (recursive={recursive})")

                  if mode == 'file':
                      ensure_parent(dst)
                      # Remove existing file if present to avoid stale content
                      if dst.exists() and dst.is_file():
                          dst.unlink()
                      shutil.copy2(src, dst)
                  elif mode == 'dir':
                      if dst.exists():
                          # Remove existing destination to get a clean mirror
                          if dst.is_dir():
                              shutil.rmtree(dst)
                          else:
                              dst.unlink()
                      if recursive:
                          shutil.copytree(src, dst)
                      else:
                          # non-recursive: copy only immediate children files
                          dst.mkdir(parents=True, exist_ok=True)
                          for item in src.iterdir():
                              # Check if this item should be ignored
                              if should_ignore(item, ignore_patterns, SRC_ROOT):
                                  continue
                              if item.is_file():
                                  shutil.copy2(item, dst / item.name)
                  else:
                      print(f"Unsupported type in mapping #{i}: {mode}", file=sys.stderr)
                      sys.exit(1)

          print('Copy operations completed.')
          PY

      - name: Commit and push changes to target branch
        env:
          GH_PAT: ${{ secrets.TOKEN }}
        run: |
          set -euo pipefail
          cd target_repo
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            
            # Create commit message based on trigger type
            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              COMMIT_MSG="Manual sync from ${{ github.repository }}@${{ env.SOURCE_BRANCH }} by ${{ github.actor }}"
              if [ -n "${{ github.event.inputs.reason }}" ]; then
                COMMIT_MSG="${COMMIT_MSG} - Reason: ${{ github.event.inputs.reason }}"
              fi
              COMMIT_MSG="${COMMIT_MSG} (commit: ${{ github.sha }})"
            else
              COMMIT_MSG="Auto integrate from ${{ github.repository }}@${{ env.SOURCE_BRANCH }} (commit: ${{ github.sha }})"
            fi
            
            git commit -m "${COMMIT_MSG}"
            git push -u origin "${TARGET_BRANCH}" --force-with-lease
            echo "NO_CHANGES=false" >> "$GITHUB_ENV"
          else
            echo "No changes detected."
            echo "NO_CHANGES=true" >> "$GITHUB_ENV"
          fi
